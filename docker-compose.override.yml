# docker-compose.override.yml (Development settings)
# This file is automatically merged with docker-compose.yml for `docker-compose up`

services:
  backend:
    env_file:
      - ./backend/.env.development
    # Mount the full backend code for hot-reloading
    # The base docker-compose.yml already mounts ./backend:/app, so this overrides/confirms it.
    volumes:
      - ./backend:/app 
      - document_storage:/app/storage/documents # Ensure storage volume is still mapped
    # Use a command that enables auto-reloading for development
    command: uvicorn main:app --host 0.0.0.0 --port 8000 --reload 

  celery_worker:
    env_file:
      - ./backend/.env.development
    # Mount the full backend code for task updates without rebuild
    # The base docker-compose.yml already mounts ./backend:/app
    volumes:
      - ./backend:/app
      - document_storage:/app/storage/documents
    # Optional: Add watchmedo for auto-restarting the worker on code changes
    # command: watchmedo auto-restart --directory=./ --pattern=*.py --recursive -- celery -A tasks.worker:celery_app worker --loglevel=info
    # If not using watchmedo, the default command from base docker-compose.yml is used.

  flower:
     env_file:
      - ./backend/.env.development # Uses dev Redis broker URL

  frontend:
    env_file:
      - ./frontend/.env.development
    # Use a development-specific build stage if available in frontend/Dockerfile
    # build:
    #   context: ./frontend
    #   target: development 
    # Mount full frontend code for hot-reloading
    # Exclude node_modules to use container's node_modules, avoiding OS conflicts
    volumes:
      - ./frontend:/app
      - /app/node_modules 
      - /app/.next # Persist .next cache between runs if desired
    # Run the development server command
    command: npm run dev 